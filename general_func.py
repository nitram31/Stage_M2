from Bio import SeqIO, Seq
from mieaa import API

def write_file(path, body):
    with open(path, 'w') as file:
        file.write(body)
def mature_to_precursor(mature):
    mieaa_api = API()
    return mieaa_api.to_precursor(mature)



def lower_list(l):
    return [el.lower() for el in l]


class brumir2refreader:
    """
    Read brumir2ref file and store it in a dictionary of the following format:

    {'mirna_id': {'chr': str,
              'start': int,
              'stop': int,
              'mfe': float,
              'precursor_seq': str
              'annotation': str'}}

    'mirna_id' (str):
    This is a string key that represents the unique identifier of a microRNA.

    'chr' (str):
    This is a string key that represents the chromosome location of the microRNA.

    'start' (int):
    This is an integer key that represents the starting position of the microRNA on the chromosome.

    'stop' (int):
    This is an integer key that represents the stopping position of the microRNA on the chromosome.

    'mfe' (float):
    This is a floating point key that represents the minimum free energy (MFE) of the microRNA.

    'precursor_seq' (str):
    This is a string key that represents the precursor sequence of the microRNA.
    """
    
    def __init__(self, file, annotation_file=None, miRNA_dict=None):
        self.miRNA_dict = miRNA_dict if miRNA_dict else {}
        self.file = file
        self.read_brumir_output()
        self.read_brumir_annotation(annotation_file) if annotation_file else None

    def get_dict(self):
        return self.miRNA_dict
    
    def read_brumir_output(self):
        with open(self.file, 'r') as f:
            for line in f:
                if line.startswith('#'): 
                    header = lower_list(line.strip('\n').split('\t'))
                    continue
                line_split = line.strip('\n').split('\t')
                miRNA_id = line_split[1]
                if miRNA_id not in self.miRNA_dict:
                    self.miRNA_dict[miRNA_id] = {"chr": [line_split[2]], "start": [line_split[3]], "stop": [line_split[4]], "mfe": [line_split[5]], "precursor_seq": [line_split[15]], 'annotation': ['novel']}
                else:
                    for key in self.miRNA_dict[miRNA_id]:
                        if key == 'annotation':
                            continue
                        else:
                            self.miRNA_dict[miRNA_id][key].append(line_split[header.index(key)])
                    self.miRNA_dict[miRNA_id]['annotation'] = ['novel' for i in range(len(self.miRNA_dict[miRNA_id]['chr']))]

    def decide_index(self, index_list):
        for i in index_list:
            if index_list.count(i) > 1:
                return i
        return -1
    
    def read_brumir_annotation(self, annotation_file):
        """Reads any brumir annotation generated by blastn, provided that there is only one annotation per position. 
        Annotation file must be tsv with the following columnsin this order: qseqid sseqid evalue pident qcovus bitscore stitle"""
        
        if self.miRNA_dict == {}:
            exit("Error: brumir2ref file must be read before annotation file.")
    
        with open(annotation_file, 'r') as f:
            for line in f:
                line_split = line.strip('\n').split('\t')

                if '_' not in line_split[0] or len(line_split[0].split('_')) != 4: 
                    exit("""Error: brumir2ref id must be in the first column of the annotation file and complemented with chromosome, start and end position, using the following awk command: tail -n+2 <brumir2ref_output> | awk '{print ">"$2"_"$3"_"$4"_"$5"\n"$16}' > output.fa""")
                
                brumir_id, chr, start, end = line_split[0].split('_')
                current_dict = self.miRNA_dict[brumir_id]
                
                if brumir_id not in self.miRNA_dict:
                    print(f'Warning: "{brumir_id}" brumir id not found in brumir2ref output.')
                    continue
                else:
                    index_list = [current_dict['chr'].index(chr), current_dict['start'].index(start), current_dict['stop'].index(end)]
                    index = self.decide_index(index_list)
                    if index == -1:
                        print(f'Warning: coordinates do not match for "{brumir_id}" brumir id.')
                    else:
                        self.miRNA_dict[brumir_id]['annotation'][index] = line_split[1]
    
    def to_bed(self, file_name=str):
        #mirdeep2_score_known_mirbaseid_chr1:beg:end:strand
        output = ""
        for miRNA_id in self.miRNA_dict:
            for i in range(len(self.miRNA_dict[miRNA_id]['chr'])):
                start = self.miRNA_dict[miRNA_id]['start'][i]
                end = self.miRNA_dict[miRNA_id]['stop'][i]
                strand = '.' # no strand information available
                chromosome = self.miRNA_dict[miRNA_id]['chr'][i]
                score = "NA" # no score available
                annotation = self.miRNA_dict[miRNA_id]['annotation'][i] if self.miRNA_dict[miRNA_id]['annotation'][i] != 'novel' else 'NA'
                status = 'known' if annotation != 'NA' else 'novel'
                source = 'Brumir2ref'
        
                output += f'{chromosome}\t{start}\t{end}\t{source}_{score}_{status}_{annotation}_{miRNA_id}_{chromosome}:{start}:{end}:{strand}\t{strand}\n'
        if file_name != str:
            with open(file_name, 'w') as f:
                f.write(output)
        else:
            return output

class mirdentifyreader:
    """
    This class reads the output of mirdentify and stores the information in a dictionary of default structure {'novel':{mirna_id:{key: value}}, 'known':{...}})
    The following keys can be used to store information about a microRNA sequence:

    "name": The name of the microRNA.

    "position": The position of the microRNA in the genome.
    
    "strand": The strand on which the microRNA is located.
    
    "start" : An integer representing the starting position of the miRNA on the chromosome.

    "end" : An integer representing the ending position of the miRNA on the chromosome.

    "chromosome" : A string representing the chromosome on which the miRNA is located.

    "source" : A string representing the source of the miRNA annotation or prediction, if applicable.
    
    "sequence" (pre-mir): The sequence of the precursor microRNA.
    
    "total reads": The total number of reads for this microRNA.
    
    "sequence (5p arm)": The sequence of the 5' arm of the mature microRNA.
    
    "5p reads": The number of reads for the 5' arm of the mature microRNA.
    
    "sequence (3p arm)": The sequence of the 3' arm of the mature microRNA.
    
    "3p reads": The number of reads for the 3' arm of the mature microRNA.
    
    "loop reads": The number of reads for the loop region of the precursor microRNA.
    
    "5' end heterogeneity (5p arm)": The heterogeneity at the 5' end of the 5' arm of the mature microRNA.
    
    "5' end heterogeneity (3p arm)": The heterogeneity at the 5' end of the 3' arm of the mature microRNA.
    
    "overhang (5p arm)": The overhang at the 3' end of the 5' arm of the mature microRNA.
    
    "overhang (3p arm)": The overhang at the 3' end of the 3' arm of the mature microRNA.
    
    "mfe (duplex)": The minimum free energy of the duplex structure of the mature microRNA.
    
    "mfe (flanking sequence)": The minimum free energy of the flanking sequence of the mature microRNA.
    
    "nucleotide entropy": The entropy of the nucleotide sequence of the mature microRNA.
    
    "structural entropy": The entropy of the structural features of the mature microRNA.
    
    "tailing factor": The tailing factor of the mature microRNA.
    
    "multimap factor": The multimap factor of the mature"""
    
    def __init__(self, miRNA_dict=None, novel=str, known=str):
        self.source = 'mirdentify'
        self.files = [novel, known]
        self.file_types = ['novel', 'known']
        self.novel = novel
        self.known = known
        
        self.miRNA_dict = {'novel':{}, 'known':{}} if miRNA_dict == None else miRNA_dict
        self.read_mirdentify()
        
    def to_bed(self, file_type=None, file_name=None):
        #mirdentify_score_known_mirbaseid_chr1:beg:end:strand
        output = ''
        if self.miRNA_dict == {'novel':{}, 'known':{}}: self.read_mirdentify()
        if file_type == None: 
            for file_type in self.miRNA_dict: 
                output += self.to_bed(file_type)
        else:
            current_dict = self.miRNA_dict[file_type]
            for miRNA_id in current_dict:
                for i in range(len(current_dict[miRNA_id]['start'])):
                    miRNA_id_nospace = miRNA_id.replace(' ', '-')
                    mirbase_id = 'NA'
                    if file_type == 'known': mirbase_id = miRNA_id_nospace
                    
                    start = current_dict[miRNA_id]['start'][i]
                    end = current_dict[miRNA_id]['end'][i]
                    strand = current_dict[miRNA_id]['strand'][i]
                    chromosome = current_dict[miRNA_id]['chromosome'][i]
                    source = current_dict[miRNA_id]['source']
                    score = 'NA'
            
                    output += f'{chromosome}\t{start}\t{end}\t{source}_{score}_{file_type}_{mirbase_id}_{miRNA_id_nospace}_{chromosome}:{start}:{end}:{strand}\t{strand}\n'
        if file_name != None:
            with open(file_name, 'w') as f:
                f.write(output)
        else:
            return output

        
    def get_dict(self):
        return self.miRNA_dict
    
    def read_mirdentify(self):
        for file, file_type in zip(self.files, self.file_types):
            if file == str: continue
            self.read_file(file, file_type)
        if self.miRNA_dict != {'novel':{}, 'known':{}}:
            return self.miRNA_dict  
        else: 
            raise ValueError("No files were read")

    
    def read_file(self, path, file_type):
        current_dict = self.miRNA_dict[file_type]
        content = open(path, 'r').read().splitlines()
        header = content[0].split(';')
        for line in content[1:]:
            line_split = line.split(';')
            miRNA_id = line_split[0]

            if miRNA_id not in current_dict: current_dict[miRNA_id] = {}
            #header is of this expected form : Name;Position;Strand;Sequence (pre-miR);Total Reads;Sequence (5p arm);5p reads;Sequence (3p arm);3p reads;Loop reads;5' end heterogeneity (5p arm);5' end heterogeneity (3p arm);Overhang (5p arm);Overhang (3p arm);MFE (duplex);MFE (flanking sequence);Nucleotide entropy;Structural entropy;Tailing factor;Multimap factor;

            for col, val in zip(header[1:], line_split[1:]):
                col = col.lower()
                if col not in current_dict[miRNA_id]:
                    current_dict[miRNA_id][col] = [val]  
                else: 
                    current_dict[miRNA_id][col].append(val)

            current_dict[miRNA_id]['source'] = self.source
            position = current_dict[miRNA_id]['position'][-1]
            chromosome = position.split('_')[0]
            start, end = position.split('_')[-1].split(':')[1].split('-')
            if 'chromosome' not in current_dict[miRNA_id]:
                current_dict[miRNA_id]['chromosome'] = [chromosome]
            else:
                current_dict[miRNA_id]['chromosome'].append(chromosome)
            if 'start' not in current_dict[miRNA_id] and 'end' not in current_dict[miRNA_id]:
                current_dict[miRNA_id]['start'] = [start]
                current_dict[miRNA_id]['end'] = [end]
            else:
                current_dict[miRNA_id]['start'].append(start)
                current_dict[miRNA_id]['end'].append(end)


    
class fastareader:
    def __init__(self, path, miRNA_dict=None, attribute=None, value=None):
        self.path = path
        self.attribute = attribute
        self.value = value
        if not miRNA_dict:
            self.miRNA_dict = {}
        else:
            self.miRNA_dict = miRNA_dict
        self.read_fasta()
        
    def get_dict(self):
        return self.miRNA_dict
    
    def read_fasta(self):
        for record in SeqIO.parse(self.path, "fasta"):
            
            self.miRNA_dict[record.id]= {"seq": str(record.seq)}
            if self.attribute and self.value:
                self.miRNA_dict[record.id][self.attribute] = self.value
        

class bedreader:
    def __init__(self, path, bed_dict=None, attribute=None, value=None):
        self.path = path
        self.attribute = attribute
        self.value = value
        if not bed_dict:
            self.bed_dict = {}
        else:
            self.bed_dict = bed_dict
        self.read_bed()
        self.get_dict()

    def get_dict(self):
        return self.bed_dict
    
    def read_bed(self):
        with open(self.path, 'r') as f:
            for line in f:
                line = line.split()
                # TODO: check for optional columns
                self.bed_dict[line[3]] = {'chromosome': line[0],
                                          'start': line[1],
                                          'end': line[2],
                                          'strand': line[4]
                                          }
                if self.attribute and self.value:
                    self.bed_dict[line[3]][self.attribute] = self.value



class mirdeepreader:

    """{'novel': {mirna_id: {'miRDeep2 score': float,
'estimated probability that the miRNA candidate is a true positive': float,
'rfam alert': str,
'total read count': int,
'mature read count': int,
'loop read count': int,
'star read count': int,
'significant randfold p-value': float,
'miRBase miRNA': str,
'example miRBase miRNA with the same seed': str,
'UCSC browser': str,
'NCBI blastn': str,
'consensus mature sequence': str,
'consensus star sequence': str,
'consensus precursor sequence': str,
'precursor coordinate': str,
'chromosome': str,
'strand': str,
'start': int,
'end': int,
'source': str,
'status': str}},

'known': {mirna_id: {'miRDeep2 score': float,
'estimated probability that the miRNA is a true positive': float,
'rfam alert': str,
'total read count': int,
'mature read count': int,
'loop read count': int,
'star read count': int,
'significant randfold p-value': float,
'mature miRBase miRNA': str,
'example miRBase miRNA with the same seed': str,
'UCSC browser': str,
'NCBI blastn': str,
'consensus mature sequence': str,
'consensus star sequence': str,
'consensus precursor sequence': str,
'precursor coordinate': str,
'chromosome': str,
'strand': str,
'start': int,
'end': int,
'source': str,
'status': str}}}"""
    def __init__(self, path, miRNA_dict=None):
        self.source = 'mirdeep2'
        self.mode = ''
        self.cont = False
        self.header = ''
        self.path = path
        if not miRNA_dict:
            self.miRNA_dict = {'novel':{}, 'known':{}}
        else:
            self.miRNA_dict = miRNA_dict
        self.read_mirdeep()

    def get_dict(self):
        return self.miRNA_dict

    def to_bed(self, file_type=None, file_name=None):
        #mirdeep2_score_known_mirbaseid_chr1:beg:end:strand
        output = ''
        if self.miRNA_dict == {'novel':{}, 'known':{}}: self.read_mirdeep()
        if file_type == None: 
            for file_type in self.miRNA_dict: 
                output += self.to_bed(file_type)
        else:
            current_dict = self.miRNA_dict[file_type]
            for miRNA_id in current_dict:
                mirbase_id = "NA"
                if file_type == 'known': mirbase_id = current_dict[miRNA_id]['mature miRBase miRNA']
                start = current_dict[miRNA_id]['start']
                end = current_dict[miRNA_id]['end']
                strand = current_dict[miRNA_id]['strand']
                score = current_dict[miRNA_id]['miRDeep2 score']
                source = current_dict[miRNA_id]['source']
                chromosome = current_dict[miRNA_id]['chromosome']
                output += f'{chromosome}\t{start}\t{end}\t{source}_{score}_{file_type}_{mirbase_id}_{miRNA_id}_{chromosome}:{start}:{end}:{strand}\t{strand}\n'
            
        if file_name != None:
            with open(file_name, 'w') as f:
                f.write(output)
        else:
            return output

    def read_mirdeep(self):
        path = self.path

        with open(path, 'r') as file:
            for line in file:

                if self.cont:
                    self.header = line.split('\t')
                    self.cont = False
                    continue
                elif line.startswith('novel miRNAs predicted by miRDeep2'):
                    self.cont = True
                    self.mode = 'novel'
                    continue
                elif line.startswith("mature miRBase miRNAs detected by miRDeep2"):
                    self.cont = True
                    self.mode = 'known'
                    continue
                elif self.mode == "novel":
                    current_dict = self.miRNA_dict[self.mode]
                    line_split = line.split('\t')
                    if len(line_split) != 17: continue
                    self.add_to_dict(line_split)
                elif self.mode == "known":
                    current_dict = self.miRNA_dict[self.mode]
                    line_split = line.split('\t')
                    if len(line_split) != 17: continue
                    self.add_to_dict(line_split)
                    
                    
        return self.miRNA_dict

    def add_to_dict(self, line_split):
        current_dict = self.miRNA_dict[self.mode]
        miRNA_id = line_split[0]
        for i in range(1, len(self.header)):
            if miRNA_id not in current_dict: current_dict[miRNA_id] = {}
            current_dict[miRNA_id][self.header[i].strip()] = line_split[i].strip()
        
        chromosome = miRNA_id.split('_')[0]
        coordinates = line_split[-1].split(':')[1]
        strand = line_split[-1].split(':')[2].strip()
        start = int(coordinates.split('..')[0])
        end = int(coordinates.split('..')[1])
        current_dict[miRNA_id]["chromosome"] = chromosome
        current_dict[miRNA_id]["strand"] = strand
        current_dict[miRNA_id]["start"] = start
        current_dict[miRNA_id]["end"] = end
        current_dict[miRNA_id]["source"] = self.source
        current_dict[miRNA_id]["status"] = self.mode

if __name__ == "__main__":
    brumir2ref = brumir2refreader("Python/sus_scrofa/brumir2rf_pig_liver.passfilter.txt", annotation_file="Python/sus_scrofa/SS_brumir2ref_blastn_mirbase_filtered_cov_60_gaps_5.txt")
    print(brumir2ref.get_dict())
      
    """brumir2ref = brumir2refreader("Python/fixed_b2ref.passfilter.txt")
    brumir2ref.to_bed(file_name="Python/bedfolder/GG_brumir2ref_passfilter.bed")
    mirdentifyread = mirdentifyreader(novel="Python/mirdentify/230131_1316_Novel_miRs.csv", known="Python/mirdentify/230131_1316_Annotated_miRs.csv")
    mirdentifyread.to_bed(file_name="Python/bedfolder/GG_mirdentify_known_novel.bed")
    mirdeepread = mirdeepreader("Python/result_09_02_2023_t_10_28_59.csv")
    mirdeepread.to_bed(file_name="Python/bedfolder/GG_mirdeep_known_novel.bed")"""
    

    
